# Mu workshop

<section data-background="rgba(255,255,255,0.40)">
  <img src="./img/mu-logo.png" style="height: 650px; margin-top: 50px;"/>
</section>

---

## Who are we?

**@adrianrafo** Senior Software Engineer @47Degrees

**@pepegar** Tech Lead @47Degrees

---

## Brief introduction to RPC

RPC, stands for **R**emote **P**rocedure **C**all, and it's a way of communicating
services.


## What's an IDL?

IDL stands for **I**nterface **D**efinition **L**anguage. IDLs are used to
declare communication protocols, and they commonly allow users to
declare complex messages.


## What is Avro?

**Avro** is an **Interface Definition Language** widely used in the data
engineering world.


## What is Mu?

**Mu** is an RPC library by your friendly folks @47Degrees.

![Mu documentation](./img/qr-mu.png)


## What is Mu for?

It is a Scala library (in other languages soon) to do **RPC** in a purely
functional fashion.


## How does Mu work?

**Mu** abstracts over **gRPC** framework to create purely functional
clients and servers simplifying the required code.


## What does Mu provide?

**Mu** allows you to:

- Client and Server autogenerated
- Generate Scala code given an **IDL** (Avro|OpenApi|Protobuf)

---

## Configuring SBT

We will need some **SBT** configuration in order to make this code generation
work. Let's start checking out the correct tag:

```sh
sbt "groll initial"
```

And making sure everything works with:

```sh
sbt clean compile
```


## Configuring SBT

In order to generate Scala sources from IDLs, we will use the `sbt-mu-idlgen` plugin.

Let's add this to the **project/plugins.sbt** file.

```scala
addSbtPlugin("io.higherkindness" %% "sbt-mu-idlgen" % "@MU_VERSION@")
```


## Imports

We are going to start by adding the needed import to the config file, in our case **ProjectPlugin.scala**.

```scala
import higherkindness.Mu.rpc.idlgen.IdlGenPlugin.autoImport._
```


## Configuring SBT

Now we will configure the `mu-idlGen` plugin:

```scala
idlType := "avro"
srcGenSerializationType := "AvroWithSchema"
sourceGenerators in Compile += (srcGen in Compile).taskValue
```

![](./img/qr-mu-idlgen-docs.png)


## SerializationType differences

There is two different **Avro** serialization types:

 - **Avro** -> Regular **Avro** serialization, faster but not supporting protocol evolutions.
 - **AvroWithSchema** -> Slower, but easier to evolve protocols.


## Mu modules

<!-- digraph G { -->
<!--     subgraph cluster_0 { -->
<!--         mu_common -> mu_rpc_internal_core; -->
<!--         label = "common"; -->
<!--     } -->
<!--     subgraph cluster_1 { -->
<!--         mu_rpc_channel; -->
<!--         mu_rpc_channel -> mu_common; -->
<!--         label = "transport"; -->
<!--     } -->
<!--     subgraph cluster_2 { -->
<!--         mu_rpc_netty -> mu_rpc_channel; -->
<!--         mu_rpc_okhttp -> mu_rpc_channel; -->
<!--         label = "client"; -->
<!--     } -->
<!--     subgraph cluster_3 { -->
<!--         mu_rpc_server -> { mu_common mu_rpc_channel }; -->
<!--         label = "server"; -->
<!--     } -->
<!--     subgraph cluster_4 { -->
<!--         mu_rpc_prometheus -> mu_rpc_internal_core; -->
<!--         mu_rpc_dropwizard -> mu_rpc_internal_core; -->
<!--         label = "other integrations"; -->
<!--     } -->
<!-- } -->

![modules graph](./img/modules-graph.png)

---

## Recommended way

In **Mu**, we advise users to go _**IDL** first_. This means to
declare the **IDLs** by hand first and use them as the source of
truth.


## Creating the protocol

The first thing we will need to do is to create the protocol. Today
we will use **Avro** as our **IDL**, but we can use **Protobuf** or
**Openapi** as well.


## Defining the protocol

First of all, we will need to have the following dependencies in the
`build.sbt` file.

```scala
libraryDependencies += "io.higherkindness" %% "mu-rpc-channel" % "@MU_VERSION@"
```


## The protocol

For this workshop, we will use **Avro** with the **AVDL** language.
All **AVDL** files should have one protocol definition.

```java
protocol ProtocolName {
  // all our declarations
}
```


## Defining records

**Avro records** represent product types, **like case classes**, and we
declare them with the **record** keyword:

```java
record PersonRPC {
  string name;
  int age;
}
```


## Defining unions

Unions in **Avro** are used to represent different cases, like **Enums**:

```java
record PeopleResponseRPC {
  union { PersonRPC, PeopleErrorRPC } result;
}
```


## Defining RPC messages

We use java-like syntax for defining **RPC messages**:

```java
int sum(int a, int b);
```


## AVDL documentation

You can find more information about **Avro** syntax here: https://avro.apache.org/docs/current/idl.html

![AVDL Documentation](./img/qr-avdl.png)

---

## Today's exercise

In today's exercise, we will create a simple distributed application
that will allow us to get information from people in our system.

Think on it as a person directory.


## The models protocol

In **People.avdl**, create:

- **PersonRPC**, with name and age.
- **PersonErrorRPC** for error with persons. It will need a message.
- **PersonRequestRPC**. We can ask for a particular person using a
  name or just send an empty request.
- **PersonResponseRPC** that will contain either a **Person** or a
  **PersonErrorRPC**.


## The service protocol

Now that we have the models, we need to define the communication.

In **PeopleService.avdl** import **People.avdl** and declare a message
**getPerson** that:

- Receives a **PeopleRequestRPC**.
- Returns a **PeopleResponseRPC**.


## Executing the generation

Now that the protocol is created, we can use **sbt compile** task to
generate our Scala sources from the IDL.


## Reviewing the generated code

Under the folder

```sh
protocol/target/scala-2.12/src_managed/main/.../
```

we'll find our generated sources:

- In the **People.scala** we'll have all the models.
- In the **PeopleService.scala** we'll have a tagless final algebra
  defining our interface.

---

## Creating the server from the protocol

There will be four main parts to the server module.

- **PeopleServiceImpl**
- **ServerBoot**
- **ServerProgram**
- **ServerApp**


## PeopleServiceImpl

In this class we will implement the service generated by the
**sbt-idlgen** plugin:

```scala
class PeopleServiceImpl extends PeopleService[IO] {
  // our implementation will come here.  We can
  // use, for example, a list containing the
  // state of the server.
}
```


## ServerBoot

To load dependencies and services required to start the server. Here
we'll place the server initialization.


## ServerProgram

We use this file to configure the **Mu** server.


## ServerApp

Just with the **IOApp** and the main method with only one line running
the **ServerProgram**.

---

## Creating the client from the protocol

- **PeopleServiceClient**
- **ClientBoot**
- **ClientProgram**
- **ClientApp**


## PeopleServiceClient

We are going to create a tagless final algebra to deal with the server calls:

```scala:mdoc
trait PeopleServiceClient {
  // our implementation will come here
}
```

On the companion object of our algebra, 
we find the utility to create the **Mu** client from an **host** and a **port**.


## Client implementation

Let's implement the client call to our server:

```scala:mdoc
class PeopleServiceClientImpl extends PeopleServiceClient[IO] {
  // our implementation will come here
}
```


## ClientBoot

To load dependencies and clients required to start the program.


## ClientProgram

With our client logic. In this file we'll use the clients implemented
on client-process.


## ClientApp

Just with the **IOApp** and the main method with only one line running the
**ClientProgram**.

---

## Connect to us

Use this command to connect to us:

```sh
sbt "runClient --host=adrian-xps.local:19683 --name=Foo"
```

---

## Thanks!

- [https://higherkindness.io/mu](https://higherkindness.io/mu)
- [https://avro.apache.org](https://avro.apache.org)
- [https://grpc.io/](https://grpc.io/)
